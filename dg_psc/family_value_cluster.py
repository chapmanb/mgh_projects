#!/usr/bin/env python
"""Explore the characteristics of a protein family by unsupervised clustering.

Using k-means clustering, groups together proteins in a family based on
several characteristics. This uses a local shelve database generated by the
interpro_domain_summary.py script.

Usage:
    family_value_cluster.py <interpro number> <number of clusters> <out_dir>
"""
from __future__ import with_statement
import sys
import os
import shelve
import math
import collections

from mako.template import Template
import networkx
import pylab
import numpy

from Bio import Cluster
from Bio import Fasta
from Bio.SeqUtils import IsoelectricPoint
from Bio.SeqUtils import ProtParam

def main(ipr_number, num_clusters, out_dir):
    charge_window = 75
    db_dir = os.path.join(os.getcwd(), "db")
    cur_db = shelve.open(os.path.join(db_dir, ipr_number))
    tax_graph = build_tax_graph(cur_db)
    uniprot_ids = []
    info_array = []
    for db_domain in cur_db.keys():
        if not cur_db[db_domain].get("is_uniref_child", ""):
            uniprot_ids.append(db_domain)
            db_item = cur_db[db_domain]
            cur_cluster_info = [
                    float(db_item["charge"]),
                    float(db_item["charge_region"]) * 10.0,
                    len(db_item.get("db_refs", [])) * 5.0,
                    calc_domain_distance(db_item) * 50.0,
                    #max(len(db_item.get("string_interactors", [])) - 1, 0),
                    ]
            info_array.append(cur_cluster_info)
    info_array = numpy.array(info_array)
    print 'Num genes', len(info_array), num_clusters
    cluster_ids, error, nfound = Cluster.kcluster(info_array,
            nclusters=num_clusters, npass=50)#, method='a', dist='c')
    #tree = Cluster.treecluster(info_array, method='a', dist='c')
    #cluster_ids = tree.cut(num_clusters)
    cluster_dict = collections.defaultdict(lambda: [])
    for i, cluster_id in enumerate(cluster_ids):
        cluster_dict[cluster_id].append(uniprot_ids[i])
    out_seq_file = os.path.join(out_dir, "%s-seqs.fa" % (ipr_number))
    out_seq_handle = open(out_seq_file, "w")
    for index, cluster_group in enumerate(cluster_dict.values()):
        print '***********', index
        org_dists = []
        for uniprot_id in cluster_group:
            org = cur_db[uniprot_id]["org_scientific_name"]
            distance = networkx.dijkstra_path_length(tax_graph, 'Mus musculus',
                    org)
            org_dists.append((distance, org, uniprot_id))
        org_dists.sort()
        members = []
        for d, o, u in org_dists:
            charge_plot_img = calc_charge_plot(u, cur_db[u], charge_window,
                    out_dir)
            base, ext = os.path.splitext(charge_plot_img)
            disorder_plot_img = "%s-idr%s" % (base, ext)
            rec = Fasta.Record()
            rec.title = u
            rec.sequence = cur_db[u]["seq"]
            out_seq_handle.write(str(rec) + "\n")
            members.append(dict(organism=o,
                uniprot_id=get_uniprot_links([u]),
                alt_names=get_alt_names(cur_db[u]),
                alt_ids=get_uniprot_links(cur_db[u].get("uniref_children", [])),
                charge=cur_db[u]["charge"],
                charge_region="%0.2f" % cur_db[u]["charge_region"],
                charge_plot_img=charge_plot_img,
                disorder_plot_img=disorder_plot_img,
                domains=len(cur_db[u].get("db_refs", [])),
                interactions=get_string_link(u,
                    max(len(cur_db[u].get("string_interactors", [])) - 1, 0)),
                description=cur_db[u].get("function_descr", "&nbsp;"),
                c_distance="%0.2f" % calc_domain_distance(cur_db[u]),
            ))
        with open(os.path.join(out_dir, "%s-cluster%s.html" % (
                ipr_number, index)), "w") as out_handle:
            tmpl = Template(cluster_template)
            out_handle.write(tmpl.render(cluster_members=members))
    #distribution_plot(info_array, 2)
    #distribution_plot(cur_db, "charge")
    #distribution_plot(cur_db, "charge_region")

def get_alt_names(cur_db):
    alt_names = cur_db.get('gene_names', [])
    if len(alt_names) > 0:
        return "<br/>(%s)" % (", ".join(alt_names))
    else:
        return ""

def calc_domain_distance(db_item):
    """Calculate the relative distance of the domain from the protein start.

    Our expectation is that our domains will be located in the N-terminal
    region of the protein, and this calculates the relative distance from the
    N-terminal.
    """
    domain_start = min(db_item["domain_positions"])
    return float(domain_start) / float(len(db_item["seq"]))

def get_string_link(uniprot_id, num_interactors):
    if num_interactors == 0:
        return num_interactors
    else:
        return '<a href="http://string.embl.de/newstring_cgi/' + \
            'show_network_section.pl?identifier=' + uniprot_id + \
            '">' + str(num_interactors)+'</a>'

def get_uniprot_links(uniprot_ids):
    """Generate links to uniprot for a set of IDs. Simple HTML generation.
    """
    links = ['<a href="http://www.uniprot.org/uniprot/%s">%s</a>' % ((u,) * 2)
            for u in uniprot_ids]
    if len(links) == 0:
        return '&nbsp;'
    else:
        return '<br/>'.join(links)

def calc_charge_plot(uniprot_id, cur_db, charge_window, out_dir):
    """Prepare a smoothed plot of charge distribution across the protein.
    """
    region_charges = calc_region_charges(cur_db["seq"], charge_window)
    positions = [i + 1 for i in range(len(region_charges))]
    pylab.clf()
    #pylab.yticks([i + 1 for i in range(13)])
    pylab.plot(positions, region_charges)
    pylab.ylabel('Isoelectric point')
    pylab.xlabel('Amino acid position, window start')
    pylab.axis(ymin=1)
    pylab.ylim(ymin=1, ymax=13)
    pylab.title('%s: Protein charge of %s amino acid windows' % (uniprot_id,
        charge_window))
    file_name = uniprot_id.replace(".", "_") + ".png"
    pylab.savefig(os.path.join(out_dir, file_name))
    return file_name

def calc_region_charges(seq, cur_window):
    """Perform calculation of charges via isoelectric points for a sequence.
    """
    # internal small regions, so do not deal with C and N terminal charges
    IsoelectricPoint.pKcterminal = {}
    IsoelectricPoint.pKnterminal = {}
    cur_pos = 0
    region_charges = []
    while cur_pos < len(seq) - cur_window:
        cur_seq = seq[cur_pos:cur_pos + cur_window]
        prot_analysis = ProtParam.ProteinAnalysis(str(cur_seq))
        ie_calc = IsoelectricPoint.IsoelectricPoint(cur_seq,
                prot_analysis.count_amino_acids())
        region_charges.append(ie_calc.pi())
        cur_pos += 1
    return region_charges

cluster_template = """
<html>
  <head>
    <link href="../css/base.css" media="screen" rel="stylesheet"
     type="text/css" />
  </head>
<body>
<table id="table-hor-minimalist">
<tr>
  <th><b>Organism</b></th>
  <th><b>Protein</b></th>
  <th><b>Other names</b></th>
  <th><b>Charge</b></th>
  <th><b>Regional charge</b></th>
  <th><b>Charge plot</b></th>
  <th><b>Disorder plot</b></th>
  <th><b>Domains</b></th>
  <th><b>Interactions</b></th>
  <th><b>N-terminal distance</b></th>
  <th><b>Description</b></th>
</tr>
% for member in cluster_members:
    <tr>
        <td>${member['organism']}</td>
        <td>${member['uniprot_id']}${member['alt_names']}</td>
        <td>${member['alt_ids']}</td>
        <td>${member['charge']}</td>
        <td>${member['charge_region']}</td>
        <td><a href="${member['charge_plot_img']}">
            <img height="125px" width="125px" 
             src="${member['charge_plot_img']}"/></a></td>
        <td><a href="${member['disorder_plot_img']}">
            <img height="125px" width="125px" 
             src="${member['disorder_plot_img']}"/></a></td>
        <td>${member['domains']}</td>
        <td>${member['interactions']}</td>
        <td>${member['c_distance']}</td>
        <td>${member['description']}</td>
    </tr>
% endfor
</table>
</body>
</html>
"""

def distribution_plot(item_array, index_num):
    vals = [x[index_num] for x in item_array]
    #vals = []
    #for db_domain in cur_db.keys():
    #    vals.append(cur_db[db_domain][item_key])
    pylab.hist(vals, 20)
    pylab.show()

def build_tax_graph(cur_db):
    """Build a taxonomy graph of all organisms represented with a given domain.

    This is a relative graph in that all distances are 1 back to the top level,
    but will allow estimation of evolutionary distances based on the 
    NCBI/UniProt organism lineage trees.
    """
    tax_graph = networkx.Graph()
    organisms_done = []
    use_dict = collections.defaultdict(int)
    for db_domain in cur_db.keys():
        db_item = cur_db[db_domain]
        if db_item["org_scientific_name"] not in organisms_done:
            full_lineage = db_item["org_lineage"] + \
                    [db_item["org_scientific_name"]]
            distance = 1.0
            for index in range(len(full_lineage) - 1):
                use_dict[full_lineage[index]] += 1
                tax_graph.add_edge(full_lineage[index], full_lineage[index + 1],
                        distance)
            organisms_done.append(db_item["org_scientific_name"])
    return tax_graph

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print "Incorrect arguments"
        print __doc__
        sys.exit()
    main(sys.argv[1], int(sys.argv[2]), sys.argv[3])
